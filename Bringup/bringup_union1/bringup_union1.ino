#include <SPI.h>
#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SH110X.h>
#include <Adafruit_NeoPixel.h>
// #ifdef __AVR__
// #include <avr/power.h> // Required for 16 MHz Adafruit Trinket
// #endif

#define SOLENOID_PIN_1 3
#define SOLENOID_PIN_2 12
#define SOLENOID_PIN_3 13
#define SOLENOID_PIN_4 15

#define NEOPIXEL_PIN 14
#define NUMPIXELS 40
Adafruit_NeoPixel pixels(NUMPIXELS, NEOPIXEL_PIN, NEO_GRB + NEO_KHZ800);


Adafruit_SH1107 display = Adafruit_SH1107(64, 128, &Wire);

// OLED FeatherWing buttons map to different pins depending on board:
// #if defined(ESP8266)
  #define BUTTON_A  0
  #define BUTTON_B 16
  #define BUTTON_C  2
// #elif defined(ESP32) && !defined(ARDUINO_ADAFRUIT_FEATHER_ESP32S2)
//   #define BUTTON_A 15
//   #define BUTTON_B 32
//   #define BUTTON_C 14
// #elif defined(ARDUINO_STM32_FEATHER)
//   #define BUTTON_A PA15
//   #define BUTTON_B PC7
//   #define BUTTON_C PC5
// #elif defined(TEENSYDUINO)
//   #define BUTTON_A  4
//   #define BUTTON_B  3
//   #define BUTTON_C  8
// #elif defined(ARDUINO_NRF52832_FEATHER)
//   #define BUTTON_A 31
//   #define BUTTON_B 30
//   #define BUTTON_C 27
// #else // 32u4, M0, M4, nrf52840, esp32-s2 and 328p
//   #define BUTTON_A  9
//   #define BUTTON_B  6
//   #define BUTTON_C  5
// #endif

const uint8_t LOGO[] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
0x00, 0x00, 0x01, 0xFF, 0xFF, 0x80, 0x00, 0x00, 
0x00, 0x00, 0x7E, 0x00, 0x00, 0x7E, 0x00, 0x00, 
0x00, 0x07, 0x80, 0x00, 0x00, 0x01, 0xE0, 0x00, 
0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 0x1C, 0x00, 
0x01, 0xC0, 0x00, 0x1F, 0xE0, 0x00, 0x03, 0x80, 
0x02, 0x00, 0x00, 0x0F, 0xF0, 0x00, 0x00, 0x40, 
0x0C, 0x43, 0xFC, 0x0C, 0x38, 0xFF, 0x00, 0x30, 
0x15, 0x81, 0xFE, 0x0C, 0x1C, 0x7F, 0x80, 0x38, 
0x16, 0x01, 0x87, 0x0C, 0x1C, 0x61, 0xC0, 0x28, 
0x22, 0x01, 0x83, 0x8C, 0x1C, 0x60, 0xE0, 0x64, 
0x21, 0x01, 0x83, 0x8C, 0x1C, 0x60, 0xE0, 0x94, 
0x22, 0x81, 0x83, 0x8C, 0x1C, 0x60, 0xE0, 0x14, 
0x22, 0x41, 0x83, 0x8C, 0x38, 0x60, 0xE0, 0x24, 
0x24, 0x01, 0x83, 0x8C, 0x30, 0x60, 0xE0, 0x04, 
0x20, 0x01, 0x87, 0x0C, 0x70, 0x61, 0xC0, 0x04, 
0x20, 0x01, 0x86, 0x1C, 0xC0, 0x61, 0x80, 0x04, 
0x20, 0x01, 0x8E, 0x0D, 0x80, 0x63, 0x80, 0x04, 
0x20, 0x03, 0x98, 0x0F, 0x00, 0xE6, 0x00, 0x04, 
0x10, 0x01, 0xB0, 0x0E, 0x00, 0x6C, 0x00, 0x04, 
0x08, 0x01, 0xE0, 0x0E, 0x00, 0x78, 0x00, 0x04, 
0x04, 0x01, 0xC0, 0x0F, 0x00, 0x70, 0x00, 0x08, 
0x38, 0x01, 0xC0, 0x0C, 0x00, 0x70, 0x00, 0x10, 
0x20, 0x01, 0xE0, 0x0C, 0x00, 0x78, 0x00, 0x08, 
0x20, 0x01, 0x80, 0x0C, 0x00, 0x60, 0x00, 0x04, 
0x20, 0x01, 0x80, 0x0C, 0x00, 0x60, 0x00, 0x04, 
0x20, 0x01, 0x80, 0x0C, 0x00, 0x60, 0x00, 0x04, 
0x20, 0x03, 0xC0, 0x1E, 0x00, 0xF0, 0x00, 0x04, 
0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 
0x26, 0x23, 0x36, 0x66, 0xD8, 0x64, 0x92, 0x44, 
0x25, 0x54, 0x44, 0x88, 0x94, 0x55, 0x5A, 0xA4, 
0x26, 0x52, 0x26, 0x44, 0xD4, 0x65, 0xD6, 0xA4, 
0x24, 0x51, 0x14, 0x22, 0x94, 0x45, 0x52, 0xA4, 
0x24, 0x23, 0x36, 0x66, 0xD8, 0x45, 0x52, 0x44, 
0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1C, 
0x21, 0x00, 0x19, 0x88, 0x59, 0x38, 0x00, 0x24, 
0x36, 0x00, 0x15, 0x54, 0x52, 0x90, 0x00, 0x44, 
0x28, 0x00, 0x19, 0x94, 0x5A, 0x10, 0x00, 0x44, 
0x20, 0x00, 0x11, 0x55, 0x52, 0x90, 0x00, 0x04, 
0x20, 0x00, 0x11, 0x48, 0x99, 0x10, 0x00, 0x04, 
0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 
0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 
0x09, 0xDC, 0x9D, 0xDC, 0x9D, 0xC9, 0xDD, 0xD0, 
0x09, 0xDC, 0x9D, 0xDC, 0x9D, 0xC9, 0xDD, 0xD0, 
0x09, 0xDC, 0x9D, 0xDC, 0x9D, 0xC9, 0xDD, 0xD0, 
0x09, 0xDC, 0x9D, 0xDC, 0x9D, 0xC9, 0xDD, 0xD0, 
0x09, 0xDC, 0x9D, 0xDC, 0x9D, 0xC9, 0xDD, 0xD0, 
0x09, 0xDC, 0x9D, 0xDC, 0x9D, 0xC9, 0xDD, 0xD0, 
0x08, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x90, 
0x08, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x90, 
0x0F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF0};
const unsigned int LOGO_SIZE = sizeof(LOGO) / sizeof(LOGO[0]);

void lightAll(unsigned char red, unsigned char green, unsigned char blue, unsigned int wait)
{
    uint32_t color = pixels.Color(red, green, blue);
    for (int i = 0; i < NUMPIXELS; i++)
    {
        pixels.setPixelColor(i, color);
    }
    pixels.show();
    delay(wait);
}

void off()
{
    for (int i = 0; i < NUMPIXELS; i++)
    {
        pixels.setPixelColor(i, 0x000000);
    }
    pixels.show();
}

void loadLogo()
{
    unsigned int x = 0;
    unsigned int y = 0;
    for (unsigned int byte = 0; byte < LOGO_SIZE; byte++)
    {
        for (unsigned int bit = 0; bit < 8; bit++)
        {
            display.drawPixel(y, 63 - x, (LOGO[byte] >> (7 - bit)) & 0x01);
            x++;
        }
        if (x >= 64)
        {
            x = 0;
            y++;
        }
    }
    display.display();
}

void setup() {
    Serial.begin(115200);

#if defined(__AVR_ATtiny85__) && (F_CPU == 16000000)
    clock_prescale_set(clock_div_1);
#endif
    pixels.begin(); // INITIALIZE NeoPixel strip object (REQUIRED)
    pixels.setBrightness(100);
    off();
    pixels.show();

    Serial.println("Piano Controller Booting Up...");
    delay(250); // wait for the OLED to power up
    display.begin(0x3C, true); // Address 0x3C default

    Serial.println("OLED started");

    display.clearDisplay();
    display.setRotation(1);
    loadLogo();
    display.display();
    delay(1000);

    // text display tests
    display.setTextSize(1);
    display.setTextColor(SH110X_WHITE);
    display.setCursor(54,0);
    display.print("Test Mode");
    display.setCursor(54,8);
    display.print("A=LED Strip");
    display.setCursor(54,16);
    display.print("B=Sol 1,2,3");
    display.setCursor(54,24);
    display.print("C=Sol 4");

    display.display(); // actually display all of the above

    pinMode(SOLENOID_PIN_1, OUTPUT);
    pinMode(SOLENOID_PIN_2, OUTPUT);
    pinMode(SOLENOID_PIN_3, OUTPUT);
    pinMode(SOLENOID_PIN_4, OUTPUT);
    digitalWrite(SOLENOID_PIN_1, LOW);
    digitalWrite(SOLENOID_PIN_2, LOW);
    digitalWrite(SOLENOID_PIN_3, LOW);
    digitalWrite(SOLENOID_PIN_4, LOW);
}

void testLeds()
{
    const unsigned char low = 128;
    const unsigned int delayStart = 10;
    const unsigned char lightningHigh = 192;
    const unsigned int delayLightning = 2;
    Serial.println("Testing LEDs");
    // Fade up
    for (int i = 0; i < low; i++)
        lightAll(i, 0, 0, delayStart);
    delay(1000);
    // Pulse
    for (int repeat = 0; repeat < 3; repeat++)
    {
        for (int i = lightningHigh; i > 0; i--)
            lightAll(i > low ? i : low, i, i, delayLightning);
        delay(1000);
    }
    // Fade out
    for (int i = low; i >= 0; i--)
        lightAll(i, 0, 0, delayStart);
    off();
    Serial.println("Done");
}

void testSolLow()
{
    Serial.println("Testing Low Solenoids");
    digitalWrite(SOLENOID_PIN_1, HIGH);
    delay(1000);
    digitalWrite(SOLENOID_PIN_2, HIGH);
    delay(1000);
    digitalWrite(SOLENOID_PIN_3, HIGH);
    delay(1000);
    digitalWrite(SOLENOID_PIN_1, LOW);
    digitalWrite(SOLENOID_PIN_2, LOW);
    digitalWrite(SOLENOID_PIN_3, LOW);
    delay(1000);
    Serial.println("Done");
}

void testSolHigh()
{
    Serial.println("Testing High Solenoid");
    digitalWrite(SOLENOID_PIN_4, HIGH);
    delay(1000);
    digitalWrite(SOLENOID_PIN_4, LOW);
    delay(1000);
    Serial.println("Done");
}

void loop() {
  if (!digitalRead(BUTTON_A)) 
  {
      testLeds();
  }
  if (!digitalRead(BUTTON_B))
  {
      testSolLow();
  }
  if (!digitalRead(BUTTON_C))
  {
      testSolHigh();
  }
  delay(10);
  yield();
  display.display();
}
